### 一、Golang相关面试题
##### 1、golang 中new 和 make的区别?

- **`new`**：简单分配内存并初始化为零值，返回指针。
- **`make`**：为 `slice`、`map` 和 `channel` 提供复杂的初始化和管理功能，返回集合类型的值本身。

##### 2、数组和切片的区别

- **数组（Array）**：
    - 数组是固定大小的有序序列，一旦定义，其长度就不可改变。
    - 定义方式：`var a [5]int`，这里定义了一个长度为 5 的数组，类型为 `int`。
    - 数组的大小是其类型的一部分，`[5]int` 和 `[10]int` 是不同的类型。
- **切片（Slice）**：
    - 切片是动态大小的，可以动态扩展或缩减。
    - 定义方式：`var s []int`，这里定义了一个切片，但没有初始长度。
    - 切片是动态视图，可以指向底层数组的一部分或全部。
    - 底层是由三部分组成，指向数组的指针，长度，最大容量

##### 3、说说关于chan的了解

###### 3.1 、什么是通道（`channel`）
 **通道（`channel`）** 是一种用于 goroutine 之间通信和同步的机制。通道可以看作是线程安全的队列，允许一个 goroutine 向通道发送数据，而另一个 goroutine 从通道接收数据。通道是 Go 语言并发模型的核心组成部分之一，基于 CSP（Communicating Sequential Processes）的并发模型。
###### 3.2、通道的内部机制
- **同步通道**：当通道没有缓冲区时，发送和接收操作是同步的。这意味着发送者会阻塞，直到有接收者接收数据；同样，接收者会阻塞，直到有发送者发送数据。
- **缓冲通道**：当通道带有缓冲区时，发送者可以在接收者没有准备好时将数据放入缓冲区。如果缓冲区已满，发送者会阻塞；如果缓冲区为空，接收者会阻塞。

##### 4、golang中的锁有那些？

###### 4.1、 sync.Mutex（互斥锁）
`sync.Mutex` 是最基本的互斥锁，用于保护共享资源，确保同一时间只有一个 Goroutine 访问该资源。
###### 4.2、sync.RWMutex（读写锁）
`sync.RWMutex` 是读写锁，允许多个读操作同时进行，但写操作是互斥的。这在读多写少的场景下可以提高性能


##### 5、golang中有那些关键字

    var const type struct int uint string interface defer range  
    if switch else for default continue break return byte rune 
    make new chan go func select case 

##### 6、关于main包

      main函数不能带参数
      main函数所在的包必须为main包
      main函数不能定义返回值
      main函数中可以使用flag包来获取和解析命令行参数

##### 7、 说一下程序的启动过程

######  7.1、编译阶段
- **源代码分析：** 源代码由编译器解析，检查语法和语义错误
- **依赖分析：** 编译器分析程序的依赖关系
- **生成目标代码：** 将源代码编译成目标文件(.o文件)，这是程序的中间表示形式
- **链接阶段：** 将目标文件与go运行时的代码链接在一起，生成可执行文件，go运行时环境是程序启动和运行的关键，它包含内存管理、调度、垃圾回收等功能
######  7.2、加载与初始化阶段
- **加载程序：** 操作 系统将可执行文件加载到内存中，加载器解析程序的可执行格式，确定其内存布局、入口等信息。
- **运行时环境初始化：** `内存管理器(Memory Manage)` 初始化垃圾回收器，用于管理程序的内存分配和回收 。 `调度器(Scheduler)`  初始化 gorotine 调度器，用于管理 Goroutine 的创建、调度和执行。 `线程池(Tread Pool)` 创建一个线程池，用于执行 Goroutine 。
######  7.3、 启动 main 函数
- **调用main函数**：程序的逻辑从这里开始，同时可以启动多个Goroutine ,调用其它包中的行数和方法，进行各种初始化操作

##### 8、如何优雅的退出协程
-  **Context (上下文)** ：用于在Goroutine之间传递取消信号或其它值，context.withCannel 创建一个可以取消的上下文，协程通过select 监听 ctx.Done()信号，一旦收到信号，就优雅地退出。
-  **Channel 信号**  ：创建一个 done 通道，协程监听done 通道，优雅退出
- **WaitGroup 等待所有 Goroutine 完成** ：waitGroup 跟踪 goroutine 的数量，每个goroutine 执行完毕后调用 wg.Done(), wg.wait() 等待所有goroutine 完成退出


8、了解Golang的内存管理吗？

        Golang使用了自动垃圾回收机制来管理内存，会自动检测和回收不再使用的内存。采用标记-清除算法，
    来进行标记和回收内存对象。可以减少内存泄漏和提高性能


9、调用函数传入结构体时，应该传值还是指针?说出你的理由?

    结构体传值，是会创建一个对象副本。而传指针则是对源结构体直接操作。
    
10、线程有几种模型？Goroutine的实现和优势说下？

    线程模型有：用户线程模型、内核系统模型还有轻量级线程模型。
    gorotine的实现：goroutine是由Golang运行时系统管理的，它使用了M:N的调度技术，将多个goroutine映射到少数
    的系统线程上运行，当一个Goruntine发生阻塞时，运行时系统会自动将其它可执行的goroutine进行调用，从而实现高效的并发
        优势：轻量级(创建和销毁的非常小，占用的内存也只有几k)
                并发能力强(可以创建成千上万个goroutine)
                内存占用低，
                通信机制:提供了channel来实现goroutine之间的通信

11、Goroutine什么时候会发生阻塞?

    网路IO阻塞：当Goroutine执行网路相关的读写操作时，如果没有数据可读或者暂时无法写入时，此时就会进入阻塞状态。
    channel阻塞：当Goroutine执行通道的读写操作时，如果通道为空或者已满是，也会导致goroutine阻塞
    系统阻塞：当Goroutine执行系统调度(文件IO),如果系统调用文件需要等待一段时间也会导致阻塞
    手动阻塞：手动添加互斥锁，条件变量、信号量来主动阻塞goroutine,直到满足特定条件
    
12、什么是PMG模型？有几种状态？

    PMG模型是Golang运行时系统中的一种抽象，用于描述Goroutine的调度和状态转换.
    P状态：表示协程正在执行中，
    M状态：表示协程正在等待可用的处理器，处于休眠状态。
    G状态：表示协程正处于阻塞状态。等待某个事件发生。

13、channel使用中需要注意的地方？

    避免在未初始化的channel上进行操作，不然会导致程序阻塞或panic
    避免在已关闭的channel上发送数据，如果一个channel已经被关闭，再向其发送数据会导致panic。
    重复关闭一个channel会导致panic


### 二、Http相关面试题
1、简单讲解什么是http

      Http是客户端和服务器之间数据传输的格式规范，表示超文本传输协议
      Http是超文本传输协议，用于服务器传输超文本到本地浏览器的传送协议
      Http的消息结构由请求行，请求头和请求体组成
  
2、http和https的区别

      http协议是明文传输的，不提供数据加密，所以数据不安全
      而https是在http的基础上利用SSL/TLS对数据进行加密，来保障数据的安全性
      2.1 说说Https是怎么保证数据安全的
        客户端验证服务器数字证书，这个证书从CA(数字证书认证机构)获取
        DH算法协商对称加密算法的密钥，hash算法的密钥
        SSL安全加密隧道协商完成
        网页以加密的方式传输，用协商的对称加密算法和密钥加密，用协商的hash算法进行数据完整性保护，
        保证数据不被篡改

3、http的常见的状态码有那些

      100-199 表示信息响应
      2 开头的状态码表示服务器成功响应
      3 开头的 表示重定向消息
      4 表示客户端错误响应
      5 表示服务器端出现问题

4、什么是http缓存

      Http缓存存储与请求关联的响应，并将存储的响应复用与后续请求

5、网络模型有那几层

      现在的网络模型有五层分别是: 物理层，数据链路层，网络层，传输层，应用层

6、Get 和 Post的区别

    Get和Post是Http常用的两种方法
    Get方法的请求参数是存放在Url中而get的url有长度大小，所以可携带的数据较少
    Post方法的请求参数放在Body当中长度没有限制，Get方法的请求参数是以明文
    存放在url中的，对于一些敏感数据，起不到保护作用
    Get请求的响应数据会被浏览器缓存起来，而post不会

7、什么是无状态协议,http是无状态的吗？

      无状态协议是指浏览器对于事务的处理没有记忆能力，Http是无状态的协议,
      cookie 能够让浏览器具有记忆功能
      JWT 也可以 

8、TCP的三次握手和四次挥手

      三次挥手是用来建立连接通道
      客户端发送一次SYN包用于建立与服务器的链接
      服务器接收到SYN包，则会发送SYN+ACK来做应答
      客户端收到服务的回应之后，也会发送ACK来回应服务器，此时服务器收到ACK之后双方建立链接
  
      四次挥手是用来断开连接
      客户端发送FIN包请求断开连接,并且进入FIN-wait-1等待状态,等待服务器响应
      服务器在收到断开连接请求后，立刻发送ACK包来做响应
      客户端收到服务器的ACK响应之后进入FIN-Wait-2等待状态，等待服务端的FIN包
      服务器在发送ACK确认消息之后一段时间，会发送FIN包给客户端告知客户端可以断开连接
      客户端收到FIN包后从FIN-wait-2状态改为time-wait状态,处于time-wait状态下客户端会
      发送ACK进行最后的确认，防止信息丢失。在等待一段时间后，连接关闭，客户端的所以资源都被
      释放

9、Http有那些请求方式?

      GET:  请求访问已经被URI(统一资源标识符)识别的资源，可以通过URL给服务器传递参数数据
      POST: 传输信息给服务器，与GET相似
      PUT:  传输文件，报文主体中包含文件内容，保存到对应的URI位置
      HEAD: 获取报文首部，与GET方法类似，一般用于验证URI是否有效
      DELETE:删除文件,与PUT方法相反
      OPTIONS: 查询对应URI支持的HTTP方法

10、TCP和UDP的区别

      TCP: 是基于连接的协议，在收发数据前必须建立稳定可靠的连接。
      UDP: 他是面向非链接的协议，不与对方建立可靠连接，而是直接把数据包发送过去，
    适用于只传送少量数据。对可靠性要求不高的应用环境

11、反向代理

      是指代理服务器来接收互联网上的连接请求，然后将请求数据转发给内部网络上的
    服务器，并把服务器上得到的结果返回给客户端。Nginx


三、Mysql相关面试题
1、MySQL的索引有那些

      (1)从物理结构上分为聚集索引和非聚集索引
        聚集索引:指索引的键值的逻辑顺序与表中对应行的物理顺序一致,每张表只能有一个
     聚集索引,也就是主键索引
        非聚集索引的逻辑顺序与数据行,的物理顺序不一致
      (2)从应用上可以划分为以下几类
        普通索引：Mysql的基本索引类型，没有限制，允许在定义索引的列中插入重复值和空值
    纯粹为了提高查询效率
        唯一索引：索引的值必须是唯一的，但是允许为空 (unique)
        主键索引：特殊的唯一索引，也称聚集索引，不允许有空值，由数据库帮我们自动创建
        组合索引：组合表中多个字段创建的索引，遵守最左前缀匹配规则
        全文索引：只有MylSAM引擎上才能使用，同时只支持CHAR、VARCHAR、TEXT 类型的字段使用

2、有哪些存储引擎

     InnoDB 和 MyISAM
      (1)谈谈InnoDB和MyISAM的区别
        InnoDB支持事务，而MyISAM不支持
        InnoDB支持外键，而MYISAM不支持
        这两均支持B+树数据结构的索引，但InnoDB是聚集索引，MyISAM是非聚集索引
        InnoDB必须由唯一索引(主键),如果没有指定，会自动寻找或生产一个隐藏ROW_ID
      来充当默认主键，MyISAM可以没有主键
      (2)InnoDB的优点:
        InnoDB支持事务，MyISAM不支持事务
        InnoDB支持外键，MyISAM不支持
        InnoDB是聚集索引，聚集索引的文件存放在主键索引的叶子节点上，因此InnoDB必须要有
      主键，通过主键查询加快查询速度和效率
        InnoDB恢复所花费的时间更短


3、mysql组合索引的最左前缀匹配原则

    最左前缀原则是发生在复合索引上的，只有复合索引才会有所谓的左右之分
    在检索数据时从联合索引的最左边开始匹配
    例：INDEX(a,b,c)
    where a = 1 and b =2 能用上a、b
    where b = 1 and a =2 能用上a、b （有mysql查询优化器）
    where a = 1 and c =2 能用上a 
    where b = 1 and c =2 不能

4、mysql如何优化

    设计合理的数据库结构,减少重复数据和冗余字段
    选择合适的数据类型可以减少存储空间和提高查询效率
    创建适当的索引: 提高查询效率和性能
        优化mysql查询语言，避免使用 select * 和 like % ，需要哪些字段就查哪些字段就行了，like % 可能会导致全表扫描
    占用过多的开销
    使用缓存:减少数据库的访问次数，提高性能如redis


5、mysql事务的隔离级别

    (1) 读未提交
    (2) 读已提交
    (3) 可重复读
    (4) 串行化

6、Mysql的索引主要包括以下几种类型

    BTree索引：是mysql默认的索引类型，基于b数数据结果实现，他可以加速等值查询，范围查询和排序查询等操作
    哈希索引:基于哈希表实现，可以快速进行等值查询，但是不支持范围查询和排序等操作
    全文索引: 基于全文索引技术实现，可以快速进行文本匹配查询，但是不支持排序等操作
    空间索引: 基于空间数据结构实现，可以快速进行空间范围查询，但是不支持排序等发操作，适用于空间数据 查询较多的场景

四、Redis面试题
    
1、redis的数据类型有哪些？

    字符串型，哈希，列表，集合，有序集合和位图

2、redis持久化怎么做的？

    redis持久化有两种方式：RDB和AOF
    RDB:是一种快照的持久化方式，会将数据以二进制格式保存到磁盘中,可以设置定期或手动触发保存来进行数据持久化
    AOF:是一种追加日志方式的持久化方法，将redis的写操作以文本格式追加到AOF文件中。

五、其它问题 
1、遇到bug该如何解决？

        首先要定位问题，通过查看错误日志，看看是那个接口哪条代码的出了问题，在本地代码通过dehug的模式下
    看看能不能复现刚才的hug,定位到问题之后，就可以着手开始解决


